<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="utf-8">
<title>Partida en curso</title>
<script
	src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script
	src="js/customjslib.js"
	type="text/javascript"></script>
<style>
.ui-state-highlight {
	height: 1.5em;
	line-height: 1.2em;
	background-color: lightgray;
}

.coalition_lists {
	list-style-type: none;
	margin: 0;
	padding: 0;
	width: 60%;
	min-height: 100px
}

.coalition_lists li {
	margin: 0 5px 5px 5px;
	padding: 5px;
	font-size: 1.2em;
	height: 1.5em;
}
</style>
<script type="text/javascript">
	// const BLOCKADE_PENALTY = 0.75;
	const BLOCKADE_PENALTY = "BLOCKADE_PENALTY";
	// const INLAND_BATTLE_PENALTY = 0.75;
	const INLAND_BATTLE_PENALTY = "INLAND_BATTLE_PENALTY";
	// const ECONOMY = "economicos";
	const ECONOMY = "ECONOMY";
	// const MILITARY = "militares";
	const MILITARY = "MILITARY"
	// const NAVY = "navales";
	const NAVAL = "NAVAL";
	const NAVAL_POWER = "NAVAL_POWER";
	// const INFANTRY = [ "Soldados -de todos los ejércitos-", "Reservistas -de
	// todos los ejércitos-"];
	const INFANTRY = "INFANTRY";
	// const RESERVES = "Reservistas -de todos los ejércitos-";
	const RESERVES = "RESERVES";
	// const DEVELOPED_INFRAESTRUCTURE = "Infraestructura desarrollada";
	const DEVELOPED_INFRAESTRUCTURE = "DEVELOPED_INFRAESTRUCTURE";
	// const DEVELOPED_INFRAESTRUCTURE_ROLL = 3;
	const DEVELOPED_INFRAESTRUCTURE_ROLL = "DEVELOPED_INFRAESTRUCTURE_ROLL";
	// const INFANTRY_ATTACK_PENALTY = 1 - 0.10;
	const INFANTRY_ATTACK_PENALTY = "INFANTRY_ATTACK_PENALTY";
	// const INFANTRY_DEFENSE_BONUS = 1 + 0.07;
	const INFANTRY_DEFENSE_BONUS = "INFANTRY_DEFENSE_BONUS";
	
	function getRollNumber() {
		var res = 1;
		if ($("table.previous_rolls") != null) {
			var prevRolls = $("tr.prev_roll_row");
			res = prevRolls.length + 1;
		}
		return res;
	}

	function isEmpty(obj) {
		for ( var key in obj) {
			if (obj.hasOwnProperty(key))
				return false;
		}
		return true;
	}

	function updateTextInput(input, val, id) {
		$("#" + id + "_input").val(val);
	}

	function updateSliderInput(input, val, id) {
		var id = id.replaceAll("_input", "");
		$("#" + id).val(val);
	}

	function swapButton(li, originalName) {
		var button = $(li).find(
				"button." + originalName.replaceAll(" ", "") + "_split");
		var text = $(button).text();
		if (text === "Dividir") {
			$(button).text("Borrar");
			$(button)
					.attr(
							"onclick",
							"deletePartition(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()");
		} else if (text === "Borrar") {
			$(button).text("Dividir");
			$(button)
					.attr(
							"onclick",
							"splitCountry(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()");
		}
	}

	/**
	 * Splits a country into two factions
	 * 
	 * @param: name of the country
	 */
	function splitCountry(name) {
		// Split the countries
		var escapedName = name.replaceAll(" ", "");
		var item = $("#" + escapedName + "_listitem");
		var list = $(item).parent("ul");
		var clone = $(item).clone().appendTo(list);
		var name1 = name + " 1";
		var name2 = name + " 2";
		$(clone).find("span.country_names", "li.ui-sortable-handle")
				.text(name2);
		$(item).find("span.country_names", "li.ui-sortable-handle").text(name1);
		// Balance the commitment
		var newPercentInput = $(clone).find(
				"input." + escapedName + "_percent_input");
		var originalPercentInput = $(item).find(
				"input." + escapedName + "_percent_input");
		var originalPercent = $(originalPercentInput).val();
		var newPercent = 1 - originalPercent;
		$(originalPercentInput).val(newPercent.toFixed(2));
		$(newPercentInput).val(newPercent.toFixed(2));
		balanceCommitment(name, name1, name2, originalPercent, newPercent);
		swapButton(item, name);
		swapButton(clone, name);
		// Rename the ids of the countries
		$(item).attr("id", escapedName + "1_listitem");
		$(item).find("input#" + escapedName + "_percent").attr("id",
				escapedName + "1_percent");
		$(item).find("input#" + escapedName + "_percent_input").attr("id",
				escapedName + "1_percent_input");
		$(clone).attr("id", escapedName + "2_listitem");
		$(clone).find("input#" + escapedName + "_percent").attr("id",
				escapedName + "2_percent");
		$(clone).find("input#" + escapedName + "_percent_input").attr("id",
				escapedName + "2_percent_input");
		// Limit the max commitment UI elements
		$("#" + escapedName + "2_percent").attr("max", newPercent);
		$("#" + escapedName + "2_percent_input").attr("max", newPercent);
		$("#" + escapedName + "1_percent").attr("max", originalPercent);
		$("#" + escapedName + "1_percent_input").attr("max", originalPercent);
	}

	/**
	 * Deletes the selected partition and merges it back into the full country
	 * by adding both sets of data, maintaining any losses. Basically undos all
	 * that splitCountry() did.
	 * 
	 * @param: original name of country
	 */
	function deletePartition(countryName) {
		// Delete the country partitions, leaving only the original
		var escapedName = countryName.replaceAll(" ", "");
		var clazz = escapedName + "_listitem";
		var partitions = $("li." + clazz);
		var partition1 = $(partitions[0]).find("span." + escapedName).text();
		var partition2 = $(partitions[1]).find("span." + escapedName).text();
		delete countries[partition1];
		delete countries[partition2];
		// Remove the list items and rename the ids
		var item = partitions[0];
		$(partitions[1]).remove();
		$(item).find("span.country_names", "li.ui-sortable-handle").text(
				countryName);
		$(item).find("input." + escapedName + "_percent_input").attr("max", 1);
		$(item).find("input." + escapedName + "_percent").attr("max", 1);
		$(item).find("input." + escapedName + "_percent_input").val(1);
		$(item).find("input." + escapedName + "_percent").val(1);
		$(item).attr("id", escapedName + "_listitem");
		$(item).find("input[type=range]").attr("id", escapedName + "_percent");
		$(item).find("input[type=number]").attr("id",
				escapedName + "_percent_input");
		swapButton(item, countryName);
	}

	function balanceCommitment(name, name1, name2, op, np) {
		var newCountry = $.extend(true, {}, countries[name]);
		var oldCountry = $.extend(true, {}, countries[name]);
		$.each(oldCountry, function(turn, turns) {
			$.each(turns, function(type, types) {
				$.each(types, function(name, attribute) {
					if (!isNaN(attribute)) {
						newCountry[turn][type][name] *= np;
						oldCountry[turn][type][name] *= op;
					}
				});
			})
		});
		countries[name1] = oldCountry;
		countries[name2] = newCountry;
	}

	/* Sums an array of country objects */
	function sumCoalition(coalition) {
		var x = 0;
		var sum;
		do {
			sum = $.extend(true, {}, coalition[x]);
		} while (isEmpty(coalition[x++]) && x < coalition.length);
		// Iterate countries
		for (var i = x; i < coalition.length; i++) {
			if (!isEmpty(coalition[i])) {
				// Iterate each type
				$.each(coalition[i], function(type, types) {
					// Iterate each attribute
					// sum[type] = {};
					$.each(types, function(attribute, value) {
						sum[type][attribute] += value;
					});
				});
			}
		}
		return sum;
	}

	/**
	 * Sums all the points of a coalition, before rolling the dice.
	 * 
	 * @param: a coalition object to sum its points
	 * @returns: the total sum of points
	 */
	function sumTotalPoints(coalition) {
		var sum = 0.0;
		if (!isEmpty(coalition)) {
			// Iterate each type
			$.each(coalition, function(type, types) {
				// Iterate each attribute
				$.each(types, function(attribute, value) {
					sum += value;
				});
			});
		}
		return sum;
	}

	/**
	 * Returns a country object with all its attributes multiplied by its
	 * commitment value. Also checks if the coalition is being blockaded and
	 * applies penalties
	 * 
	 * @param country:
	 *            the country in question
	 * @param c:
	 *            its resource commitment value
	 * @return: the intervention value of said country
	 */
	function calculateCommitment(country, c, blockaded) {
		var res = $.extend(true, {}, country);
		$.each(res, function(type, types) {
			$.each(types, function(name, value) {
				res[type][name] *= c;
				// Penalize for blockade
				if (blockaded && type === rules[ECONOMY]) {
					res[type][name] *= rules[BLOCKADE_PENALTY];
				}
			});
		});
		// Disable reserves for 1st roll
		var rollNumber = getRollNumber();
		if (rollNumber == 1) {
			res[rules[MILITARY]][rules[RESERVES]] = 0.0;
		}
		// Penalize reserves for underdeveloped countries
		if (Math.round(res[rules[MILITARY]][rules[DEVELOPED_INFRAESTRUCTURE]])===0) {			
			if (rollNumber < rules[DEVELOPED_INFRAESTRUCTURE_ROLL]) {
				res[rules[MILITARY]][rules[RESERVES]] = 0.0;
			}
		}
		return res;
	}

	/**
	 * Returns whether a country or its coalition is being blockaded
	 * 
	 * @param: boolean, whether the country or coalition is blockaded
	 */
	function isBlockaded(country, coalition) {
		var res = false;
		var countryCheckboxes = $("[name=" + country.replaceAll(" ", "") + "]");
		var coalitionCheckboxes = $("[name=" + coalition + "]");
		for (var i = 0; i < countryCheckboxes.length; i++) {
			res = res || $(countryCheckboxes[i]).prop("checked");
		}
		for (var i = 0; i < coalitionCheckboxes.length; i++) {
			res = res || $(coalitionCheckboxes[i]).prop("checked");
		}
		return res;
	}

	/* Gets the turn selected from the radio buttons via iteration */
	function getSelectedTurn() {
		var radioList = $("#subscenario_list").find("input:checked");
		var selectedTurn = $(radioList).val();
		return selectedTurn;
	}

	/* Updates the table with the new info */
	function drawCoalitionNavies(turn, attackerNavy, defenderNavy) {
		$("#coalition_navies").find("tr:gt(0)").remove();
		for ( var key in countries) {
			var row = $("<tr>")
			if (Math.round(countries[key][turn][rules[NAVAL]][rules[NAVAL_POWER]]) === 1.0) {
				var intervention = countries[key][turn][rules[NAVAL]];				
				var navalPowerNavy = 0;
				for (var navy in intervention) {
					// Check that avoids the naval power true/false
					if (navy!=rules[NAVAL_POWER]) {
						navalPowerNavy += intervention[navy];
					}
				}
				var c1percent = 0.0
				c1percent += attackerNavy / navalPowerNavy;
				var c2percent = 0.0
				c2percent += defenderNavy / navalPowerNavy;
				var npcell = $("<td>");
				$(npcell).append(key);
				var blockadeAttackerCheckbox = $("<input>");
				$(blockadeAttackerCheckbox).attr({
					type : "checkbox",
					// form : "war_form",
					name : "block_attacker",
					value : key.replaceAll(" ", "") + "_blocks_" + "attacker",
					onchange : "updateCountryPoints();",
				});
				var c1cell = $("<td>");
				$(c1cell).append((c1percent * 100).toFixed(2) + ": ");
				$(c1cell).append(blockadeAttackerCheckbox);
				var blockadeDefenderCheckbox = $("<input>");
				$(blockadeDefenderCheckbox).attr({
					type : "checkbox",
					// form : "war_form",
					name : "block_defender",
					value : key.replaceAll(" ", "") + "_blocks_" + "defender",
					onchange : "updateCountryPoints();",
				});
				var c2cell = $("<td>");
				$(c2cell).append((c2percent * 100).toFixed(2) + ": ");
				$(c2cell).append(blockadeDefenderCheckbox);
				$(row).append(npcell);
				$(row).append(c1cell);
				$(row).append(c2cell);
				$("#coalition_navies").append(row);
			}
		}
	}

	function drawCountryNavies(turn, countryNavies) {
		// Set up table and first row
		$("#country_navies").find("tr:gt(0)").remove();
		var firstRow = $("<tr>");
		var tableName = $("<th>");
		tableName.append("Potencias Navales");
		$(firstRow).append(tableName);
		$("#country_navies").append(firstRow);
		// Iterate once per country
		for ( var key in countries) {
			// Add a header per country
			var countryHeader = $("<th>");
			$(countryHeader).append(key);
			$(firstRow).append(countryHeader);
			// If the country is a naval power, add a row for it
			if (Math.round(countries[key][turn][rules[NAVAL]][rules[NAVAL_POWER]]) === 1.0) {
				var intervention = countries[key][turn][rules[NAVAL]];
				var navalPowerNavy = 0;
				for (var navy in intervention) {
					// Check that avoids the naval power true/false
					if (navy!=rules[NAVAL_POWER]) {
						navalPowerNavy += intervention[navy];
					}
				}
				var row = $("<tr>");
				var npcell = $("<td>");
				$(npcell).append(key);
				$(row).append(npcell);
				for ( var c in countryNavies) {
					var cpercent = 0.0;
					cpercent += countryNavies[c] / navalPowerNavy;
					var blockadeCheckbox = $("<input>");
					$(blockadeCheckbox).attr(
							{
								type : "checkbox",
								// form : "war_form",
								name : "block_" + c.replaceAll(" ", ""),
								value : key.replaceAll(" ", "") + "_blocks_"
										+ c.replaceAll(" ", ""),
								onchange : "updateCountryPoints();",
							});
					var ccell = $("<td>");
					$(ccell).append((cpercent * 100).toFixed(2) + ": ");
					$(ccell).append(blockadeCheckbox);
					$(row).append(ccell);
				}
				$("#country_navies").append(row);
			}
		}
	}

	function drawCountryPoints(attackerPoints, defenderPoints) {
		var table = $("#stat_table");
		var turn = getSelectedTurn();
		$(table).find("tr").remove();
		// Iterate the types of attributes
		$
				.each(
						attributeValuesTemplate[turn],
						function(type, attributes) {
							var header = $("<tr>");
							$(header).append($("<th>").append(type));
							$(header).append($("<th>").append("Atacante"));
							$(header).append($("<th>").append("Defensor"));
							$(table).append(header);
							// Iterate the attributes
							$
									.each(
											attributes,
											function(name, value) {
												var row = $("<tr>");
												$(row)
														.append(
																$("<td>")
																		.append(
																				name
																						+ " &#10005; "
																						+ attributeValuesTemplate[turn][type][name]
																						+ " pts."));
												var at = (attackerPoints[type] == null)
														|| isEmpty(attackerPoints[type]);
												$(row)
														.append(
																$("<td>")
																		.append(
																				(attackerPoints[type] == null)
																						|| isEmpty(attackerPoints[type]) ? 0
																						: attackerPoints[type][name]
																								.toFixed(2)));
												$(row)
														.append(
																$("<td>")
																		.append(
																				(defenderPoints[type] == null)
																						|| isEmpty(defenderPoints[type]) ? 0
																						: defenderPoints[type][name]
																								.toFixed(2)));
												$(table).append(row);
											});
						});
		// Add the sum row:
		var sumrow = $("<tr>");
		$(sumrow).append($("<th>").append("Puntos totales"));
		$(sumrow).append($("<th>").append($("<span>", {
			id : "total_attack_score"
		}).append(sumTotalPoints(attackerPoints).toFixed(2))));
		$(sumrow).append($("<th>").append($("<span>", {
			id : "total_defender_score"
		}).append(sumTotalPoints(defenderPoints).toFixed(2))));
		$(table).append(sumrow);
	}

	/* Calculates the power of navies between coalitions and naval powers */
	function updateCoalitionNavies() {
		var attackerNavy = 0.0;
		var defenderNavy = 0.0;
		var attackerCountries = $("#coal1_box").find("span.country_names",
				"li.ui-sortable-handle");
		var defenderCountries = $("#coal2_box").find("span.country_names",
				"li.ui-sortable-handle");
		var turn = getSelectedTurn();
		for (var key = 0; key < attackerCountries.length; key++) {
			var longname = $(attackerCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for (var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy!=rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $(
					"#" + longname.replaceAll(" ", "") + "_percent_input")
					.val();
			attackerNavy += navies * commitment;
		}
		for (var key = 0; key < defenderCountries.length; key++) {
			var longname = $(defenderCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for (var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy!=rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $(
					"#" + longname.replaceAll(" ", "") + "_percent_input")
					.val();
			defenderNavy += navies * commitment;
		}
		drawCoalitionNavies(turn, attackerNavy, defenderNavy);
	}

	/* Calculates the power of navies between naval powers and countries */
	function updateCountryNavies() {
		var turn = getSelectedTurn();
		var countryNavies = {};
		// Grab the names of all the countries from the table
		for ( var key in countries) {
			var longname = key;
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for (var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy!=rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $(
					"#" + longname.replaceAll(" ", "") + "_percent_input")
					.val();
			// This is so the "parent" country appears in full force when it's
			// partitioned
			if (commitment == null) {
				commitment = 1;
			}
			var finalNavy = navies * commitment;
			countryNavies[longname] = finalNavy;
		}
		drawCountryNavies(turn, countryNavies);
	}

	function downloadPointsTemplate() {
		// Reference table with points per attribute.

		attributeValueTemplate = {
			"economicos" : {
				"PIB ($ Geary-Khamis de 1990)" : 8.0,
				"Población total" : 8.0,
				"Total de la producción cerealera (trigo, maíz, centeno, avena, arroz) (Tm)" : 8.0,
				"Producción acero (Tm)" : 8.0,
				"Producción carbón (Tm)" : 8.0,
			},
			"militares" : {
				"Densidad ferroviaria (km/km2)" : 8.0,
				"Soldados -de todos los ejércitos-" : 11.0,
				"Reservistas -de todos los ejércitos-" : 11.0,
			},
			"navales" : {
				"Tonelaje desplazado por la Armada (Tm)" : 5.0,
				"Tonelaje desplazado por la marina mercante (Tm)" : 3.0,
			},
		};
	}

	function updateCountryPoints() {
		var attackerCountries = $("#coal1_box").find("span.country_names",
				"li.ui-sortable-handle");
		var defenderCountries = $("#coal2_box").find("span.country_names",
				"li.ui-sortable-handle");
		var turn = getSelectedTurn();
		// Add up the power of coalitions
		var defenders = [];
		var attackers = [];
		/*
		 * To build the coalition, iterate all its countries, and for each: 1.
		 * Get its name 2. Get the commitment 3. Get whether the coalition, or
		 * the country, is being blockaded (blockades don't stack) 4. Build an
		 * "intervention", ie a temporary version of the country, and and that
		 * to the coalition
		 */
		for (var key = 0; key < defenderCountries.length; key++) {
			// TODO: Refactor name.replaceAll() to name
			var longname = $(defenderCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var commitment = $(
					"#" + longname.replaceAll(" ", "") + "_percent_input")
					.val();
			var blockaded = isBlockaded(
					"block_" + longname.replaceAll(" ", ""), "block_defender");
			var intervention = calculateCommitment(countries[name][turn],
					commitment, blockaded, "defense");
			defenders.push(intervention);
		}
		for (var key = 0; key < attackerCountries.length; key++) {
			var longname = $(attackerCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var commitment = $(
					"#" + longname.replaceAll(" ", "") + "_percent_input")
					.val();
			var blockaded = isBlockaded(
					"block_" + longname.replaceAll(" ", ""), "block_attacker");
			var intervention = calculateCommitment(countries[name][turn],
					commitment, blockaded, "attack");
			attackers.push(intervention);
		}
		var attackerStats = sumCoalition(attackers);
		var defenderStats = sumCoalition(defenders);

		// Calculate the points
		var attackerPoints = {};
		var defenderPoints = {};
		// First, calculate the total
		var totalStats = sumCoalition([ attackerStats, defenderStats ]);
		// Iterate the total and create an object with attacker and defender
		// points
		var turn = getSelectedTurn();
		$
				.each(
						attributeValuesTemplate[turn],
						function(type, types) {
							attackerPoints[type] = {};
							defenderPoints[type] = {};
							$
									.each(
											types,
											function(name, attribute) {
												if (!isEmpty(totalStats[type])) {
													var total = totalStats[type][name];
													var points = attributeValuesTemplate[turn][type][name];
													if (!isEmpty(attackerStats)) {
														var at = attackerStats[type][name];
														attackerPoints[type][name] = (total === 0) ? attackerStats[type][name]
																: (attackerStats[type][name] / total);
														attackerPoints[type][name] *= points;
														// Apply modifiers:
														// 1. Penalize infantry
														// for attack
														if (rules[INFANTRY]
																.includes(name)) {
															attackerPoints[type][name] *= rules[INFANTRY_ATTACK_PENALTY];
														}
														// Penalize for inland
														// battles
														if (type === rules[NAVAL]
																&& $(
																		"#inland_battle")
																		.prop(
																				"checked")) {
															attackerPoints[type][name] *= rules[INLAND_BATTLE_PENALTY];
														}
													}
													if (!isEmpty(defenderStats)) {
														defenderPoints[type][name] = (total === 0) ? defenderStats[type][name]
																: (defenderStats[type][name] / total);
														defenderPoints[type][name] *= points;
														var def = defenderStats[type][name];
														// Apply modifiers
														// 1. Bonus to infantry
														// for defense
														if (rules[INFANTRY]
																.includes(name)) {
															defenderPoints[type][name] *= rules[INFANTRY_DEFENSE_BONUS];
														}
														// 2. Penalize navies
														// for inland battles
														if (type === rules[NAVAL]
																&& $(
																		"#inland_battle")
																		.prop(
																				"checked")) {
															defenderPoints[type][name] *= rules[INLAND_BATTLE_PENALTY];
														}
													}
												}
											});
						});
		drawCountryPoints(attackerPoints, defenderPoints);
	}
	
	/**
	 * Loads the previous coalitions in the coalition boxes, by searching for
	 * names in the last result table
	 */
	function loadPreviousCoalitions() {
		var lastAttackersTDs = $("td.last_attacker_country_name");
		var lastDefendersTDs = $("td.last_defender_country_name");
		var attackersList = $("ul#attacker_list");
		var defenderList = $("ul#defender_list");
		for (var i = 0; i < lastAttackersTDs.length; i++) {
			var countryLi = $("#" + $(lastAttackersTDs[i]).text().replace(" ", "") + "_listitem");
			$(attackersList).append(countryLi);
		}
		for (var i = 0; i < lastDefendersTDs.length; i++) {
			var countryLi = $("#" + $(lastDefendersTDs[i]).text().replace(" ", "")  + "_listitem");
			$(defenderList).append(countryLi);
		}
	}

	$(document).ready(
			function() {
				// Load the previous coalitions if they exist
				loadPreviousCoalitions();
				// Sortable list to drag countries to coalitions
				$("ul#country_list, ul#attacker_list, ul#defender_list")
						.sortable({
							connectWith : ".coalition_lists",
							dropOnEmpty : true,
							placeholder : "ui-state-highlight",
							update : function() {
								updateCoalitionNavies();
								updateCountryNavies();
								updateCountryPoints();
								$(this).clone()
							},
						});

				$("ul.coalition_lists").disableSelection();

				$("#war_form").submit(
						function() {
							// Submit the scores
							$("#attacker_score").val(
									$("#total_attack_score").text());
							$("#defender_score").val(
									$("#total_defender_score").text());
							// Submit the coalitions as a string list such as
							// country,percent; to be parsed by the server
							var attacker = "";
							$.each($("#coal1_box").find("li"), function(key,
									val) {
								attacker += $(val).attr("name")
										+ ","
										+ $(val).find("input[type=number]")
												.val() + ";";
							});
							$("#attacker_countries").val(attacker);
							var defender = "";
							$.each($("#coal2_box").find("li"), function(key,
									val) {
								defender += $(val).attr("name")
										+ ","
										+ $(val).find("input[type=number]")
												.val() + ";";
							});
							$("#defender_countries").val(defender);
							return true;
						});
				// Ajax call to get all rules
				$.ajax({
					type : "POST",
					url : "/mapRules",
					success : function(response) {
						rules = response;
						// Ajax call to get the points template
						$.ajax({
							type : "POST",
							url : "/mapAttributes",
							success : function(response) {
								attributeValuesTemplate = response;
								downloadPointsTemplate();
								// Ajax call to get all country data to display
								// in tables
								// dynamically
								$.ajax({
									type : "POST",
									url : "/mapCountries",
									success : function(response) {
										countries = response;
										updateCoalitionNavies();
										updateCountryNavies();
										updateCountryPoints();
									}
								});
							}
						});
					}
				});
			});
</script>
</head>
<body>
<nav>
<form
	action="#"
	th:action="@{/openGame}"
	method="get">
<input type="hidden"
	name="game_id"
	th:value="${session.game.id}">
	<input
		type="submit"
		value="Volver a la p&aacute;gina del enfrentamiento">
</form>
<nav>
<form
	action="#"
	th:action="@{/landing}"
	method="get">
	<input
		type="submit"
		value="Volver a la p&aacute;gina principal">
</form>
</nav>
	<article>
		<th:block th:if="${rolls!=null and !rolls.empty}">
			<section
				th:each="roll, rollStats : ${rolls}"
				th:if="${rollStats.index == rollStats.size-1}"
				id="last_roll_result">
				<h3>Resultado de la &uacute;ltima tirada</h3>
				<table
					id="last_result"
					border="1">
					<tr>
						<th colspan="4">Puntuaci&oacute;n</th>
					</tr>
					<tr>
						<th
							colspan="2"
							th:text="${roll.attacker.name}"></th>
						<th
							colspan="2"
							th:text="${roll.defender.name}"></th>
					</tr>
					<tr>
						<td colspan="2">
							<table
								id="last_attacker_result_table"
								border="1"
								style="width: 100%;">
								<tr th:each="inv, invStats : ${roll.attacker.involvements}">
									<td
										class="last_attacker_country_name"
										th:text="${inv.country.name}"></td>
									<td
										class="last_attacker_country_percent"
										th:text="${inv.involvementPercent}"></td>
								</tr>
							</table>
					</td>
					<td colspan="2">
						<table
							id="last_defender_result_table"
							border="1"
							style="width: 100%;">
							<tr th:each="inv, invStats : ${roll.defender.involvements}">
								<td
									class="last_defender_country_name"
									th:text="${inv.country.name}"></td>
								<td
									class="last_defender_country_percent"
									th:text="${inv.involvementPercent}"></td>
							</tr>
						</table>
					</td>
					</tr>
					<tr>
						<th
							colspan="2"
							th:text="${roll.attackerScore}"></th>
						<th
							colspan="2"
							th:text="${roll.defenderScore}"></th>
					</tr>
				</table>
			</section>
		</th:block>
		<h2>Comenzar una tirada</h2>
		<section>
			<h3>Nombre</h3>
			<form
				id="war_form"
				name="war_form"
				action="#"
				th:action="@{/createRoll}"
				method="post">
				<label>Nombre:</label>
				<div th:switch="${session.war.id==null}">
					<input
						th:case="${true}"
						type="text"
						name="name"
						th:value="${name}">
					<input
						th:case="${false}"
						type="text"
						name="name"
						th:value="${session.war.name}"
						readonly="readonly">
				</div>
				<input
					type="hidden"
					name="attacker_score"
					id="attacker_score"
					value="0">
				<input
					type="hidden"
					name="defender_score"
					id="defender_score"
					value="0">
				<input
					type="hidden"
					name="attacker_countries"
					id="attacker_countries"
					value="">
				<input
					type="hidden"
					name="defender_countries"
					id="defender_countries"
					value="">
			</form>
		</section>
		<section>
			<h3>Subescenario</h3>
			<ul id="subscenario_list">
				<li th:each="turn, turnStat : ${turns}">
					<label th:text="${turn.subscenario}"></label>
					<input
						type="radio"
						th:name="subscenario"
						th:class="subscenario_radio"
						th:id="${turn.subscenario}"
						th:value="${turn.subscenario}"
						th:checked="${session.game.activeTurn==turn}"
						form="war_form"
						th:disabled="${session.game.activeTurn!=turn}">
				</li>
			</ul>
		</section>
		<section id="coalition_section">
			<h3>Coaliciones</h3>
			<div>
				<h4>Coalici&oacute;n Atacante</h4>
				<div
					id="coal1_box"
					style="border: solid 2px;">
					<ul
						id="attacker_list"
						class="coalition_lists"></ul>
				</div>
				<label>Nombre coalici&oacute;n atacante</label>
				<input
					type="text"
					name="attacker_name"
					th:value="${lastRoll?.attacker?.name} != null ? ${lastRoll?.attacker?.name} : ${attackerString}"
					th:readonly="${lastRoll!=null}"
					form="war_form">
				<h4>Coalici&oacute;n Defensora</h4>
				<div
					id="coal2_box"
					style="border: solid 2px;">
					<ul
						id="defender_list"
						class="coalition_lists"></ul>
				</div>
				<label>Nombre coalici&oacute;n defensora</label>
				<input
					type="text"
					name="defender_name"					
					th:value="${lastRoll?.defender?.name} != null ? ${lastRoll?.defender?.name} : ${defenderString}"
					th:readonly="${lastRoll!=null}"
					form="war_form">
			</div>
			<h4>Pa&iacute;ses</h4>
			<div style="border: solid 2px;">
				<ul
					id="country_list"
					class="coalition_lists">
					<li
						th:each="country : ${countries}"
						th:class="${#strings.replace(country.name, ' ', '') + '_listitem'}"
						th:id="${#strings.replace(country.name, ' ', '') + '_listitem'}"
						th:name="${country.name}">
						<span
							th:class="'country_names ' + ${country.name}"
							th:text="${country.name}"></span>
						<input
							type="range"
							min=0
							max=1
							step=0.01
							value=1
							th:name="${#strings.replace(country.name, ' ', '') + '_percent'}"
							th:id="${#strings.replace(country.name, ' ', '') + '_percent'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_percent'}"
							oninput="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateTextInput(this, this.value, this.id);"
							onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateTextInput(this, this.value, this.id);">
						<input
							type="number"
							th:name="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							th:id="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							min=0
							max=1
							step=0.01
							value=1
							oninput="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateSliderInput(this, this.value, this.id);"
							onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateSliderInput(this, this.value, this.id);">
						<!--						TODO: JQUERY validate this to max 1  -->
						<button
							type="button"
							th:name="${country.name + '_split'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_split'}"
							th:id="${country.name + '_split'}"
							th:value="${country.name}"
							onclick="splitCountry(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()">Dividir</button>
					</li>
				</ul>
			</div>
			<div>
				<form
					action="#"
					th:action="@{/endWar}"
					method="get">
					<input
						type="submit"
						value="Terminar Enfrentamiento">
				</form>
			</div>
		</section>
		<section>
			<h3>Armadas</h3>
			<div>
				<label for="inland_battle">Batalla Interior</label>
				<input
					type="checkbox"
					id="inland_battle"
					name="inland_battle"
					value="inland_battle"
					form="war_form"
					onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints()">
			</div>
			<div>
				<h4>Potencias navales vs. Coaliciones</h4>
				<table
					id="coalition_navies"
					border="2">
					<tr>
						<th>Potencias navales</th>
						<th>Porcentaje coalici&oacute;n atacante</th>
						<th>Porcentaje coalici&oacute;n defensora</th>
					</tr>
				</table>
			</div>
			<div>
				<h4>Potencias navales vs. Pa&iacute;ses</h4>
				<table
					id="country_navies"
					border="2">
					<tr>
					</tr>
				</table>
			</div>
		</section>
		<section>
			<h3>Puntos disponibles para la tirada actual</h3>
			<table
				id="stat_table"
				border="2">
			</table>
			<input
				type="submit"
				value="Tirar dado"
				form="war_form">
		</section>
		<section th:if="${session.war.id != null}">
			<h3>Puntos acumulados</h3>
			<table border="2" class="previous_rolls">
				<tr>
					<th>Puntos por tirada</th>
					<th>Atacante</th>
					<th>Defensor</th>
				</tr>
				<tr th:each="roll, rollStats : ${rolls}" class="prev_roll_row">
					<td th:switch="${rollStats.index}"><span th:case="0">Primera
							Tirada &#10005; 0.15 puntos</span> <span th:case="1">Segunda
							Tirada &#10005; 0.25 puntos</span></td>
					<td th:text="${roll.attackerScore}"></td>
					<td th:text="${roll.defenderScore}"></td>
				</tr>
				<tr id="total_score">
					<th>Puntuaci&oacute;n total</th>
					<th id="attacker_total_score"></th>
					<th id="defender_total_score"></th>
				</tr>
			</table>
		</section>
	</article>
</body>
</html>