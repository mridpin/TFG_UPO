<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="utf-8">
<title>Partida en curso</title>
<link
	rel="stylesheet"
	href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
	integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
	crossorigin="anonymous">
<link
	href="css/bulma.css"
	rel="stylesheet">
<script
	src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script
	src="js/jquery.validate.js"
	type="text/javascript"></script>
<script
	src="js/customjslib.js"
	type="text/javascript"></script>
<style>
.ui-state-highlight {
	height: 1.5em;
	line-height: 1.2em;
	background-color: lightgray;
}

.coalition_lists {
	list-style-type: none;
	margin: 0;
	padding: 0;
	min-height: 150px
}

.coalition_lists li {
	margin: 0 5px 5px 5px;
	padding: 5px;
	font-size: 1.2em;
	height: 1.5em;
}
</style>
<script type="text/javascript">
	// const BLOCKADE_PENALTY = 0.75;
	const BLOCKADE_PENALTY = "BLOCKADE_PENALTY";
	// const INLAND_BATTLE_PENALTY = 0.75;
	const INLAND_BATTLE_PENALTY = "INLAND_BATTLE_PENALTY";
	// const ECONOMY = "economicos";
	const ECONOMY = "ECONOMY";
	// const MILITARY = "militares";
	const MILITARY = "MILITARY"
	// const NAVY = "navales";
	const NAVAL = "NAVAL";
	const NAVAL_POWER = "NAVAL_POWER";
	// const INFANTRY = [ "Soldados -de todos los ejércitos-", "Reservistas -de
	// todos los ejércitos-"];
	const INFANTRY = "INFANTRY";
	// const RESERVES = "Reservistas -de todos los ejércitos-";
	const RESERVES = "RESERVES";
	// const DEVELOPED_INFRAESTRUCTURE = "Infraestructura desarrollada";
	const DEVELOPED_INFRAESTRUCTURE = "DEVELOPED_INFRAESTRUCTURE";
	// const DEVELOPED_INFRAESTRUCTURE_ROLL = 3;
	const DEVELOPED_INFRAESTRUCTURE_ROLL = "DEVELOPED_INFRAESTRUCTURE_ROLL";
	// const INFANTRY_ATTACK_PENALTY = 1 - 0.10;
	const INFANTRY_ATTACK_PENALTY = "INFANTRY_ATTACK_PENALTY";
	// const INFANTRY_DEFENSE_BONUS = 1 + 0.07;
	const INFANTRY_DEFENSE_BONUS = "INFANTRY_DEFENSE_BONUS";

	function toggleTurns() {
		$("ul#subscenario_list").toggle();
	}

	function validateAttackers() {
		var res = [];
		var attackerCountries = $("#coal1_box").find("span.country_names", "li.ui-sortable-handle");
		if (attackerCountries.length === 0) {
			res.push("La coalici&oacute;n atacante est&aacute; vac&iacute;a. ");
		}
		if (attackerCountries.length === countries.length) {
			res.push("Todos los pa&iacute;ses no pueden estar en la coalici&oacute;n atacante. ");
		}
		// These validate for both attackers and defenders
		var countrynames = [];
		for ( var key in countries) {
			var clazz = key.replaceAll(" ", "") + "_listitem";
			countrynames[key] = $("." + clazz);
		}
		for ( var key in countrynames) {
			var countryInvolvement = 0;
			for (var inv = 0; inv < countrynames[key].length; inv++) {
				countryInvolvement += parseFloat($(countrynames[key][inv]).find("input[type=number]").val());
			}
			if (countryInvolvement > 1.0) {
				res.push("El pa&iacute;s " + key + " est&aacute; usando m&aacute;s del 100% de sus recursos. ");
			}
		}
		return res;
	}

	function validateDefenders() {
		var res = [];
		var defenderCountries = $("#coal2_box").find("span.country_names", "li.ui-sortable-handle");
		if (defenderCountries.length === 0) {
			res.push("La coalici&oacute;n defensora est&aacute; vac&iacute;a. ");
		}
		if (defenderCountries.length === countries.length) {
			res.push("Todos los pa&iacute;ses no pueden estar en la coalici&oacute;n defensora. ");
		}
		return res;
	}

	function validateDieRoll() {
		var res = [];
		var ret = true;
		$("ul#error_list").empty();
		var attackerErrors = validateAttackers();
		var defenderErrors = validateDefenders();
		if (attackerErrors.length > 0) {
			res.push(attackerErrors);
			ret = false;
		}
		if (defenderErrors.length > 0) {
			res.push(defenderErrors);
			ret = false;
		}
		if (res.length !== 0) {
			for ( var i in res) {
				if (res[i] != "") {
					var li = $("<li>").append(res[i]);
					$("ul#error_list").append(li);
				}
			}
			$("#error_section").show();
		} else {
			$("#error_section").hide();
		}
		return ret;
	}

	function getRollNumber() {
		var res = 1;
		if ($("table.previous_rolls") != null) {
			var prevRolls = $("tr.prev_roll_row");
			res = prevRolls.length + 1;
		}
		return res;
	}

	function isEmpty(obj) {
		for ( var key in obj) {
			if (obj.hasOwnProperty(key))
				return false;
		}
		return true;
	}

	function updateTextInput(input, val, id) {
		$("#" + id + "_input").val(val);
	}

	function updateSliderInput(input, val, id) {
		var id = id.replaceAll("_input", "");
		$("#" + id).val(val);
	}

	function swapButton(li, originalName) {
		var button = $(li).find("button." + originalName.replaceAll(" ", "") + "_split");
		var text = $(button).text();
		if (text === "Dividir") {
			$(button).text("Borrar");
			$(button).attr("onclick",
					"deletePartition(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()");
		} else if (text === "Borrar") {
			$(button).text("Dividir");
			$(button).attr("onclick",
					"splitCountry(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()");
		}
	}

	/**
	 * Splits a country into two factions
	 * 
	 * @param: name of the country
	 */
	function splitCountry(name) {
		// Split the countries
		var escapedName = name.replaceAll(" ", "");
		var item = $("#" + escapedName + "_listitem");
		var list = $(item).parent("ul");
		var clone = $(item).clone().appendTo(list);
		var name1 = name + " 1";
		var name2 = name + " 2";
		$(clone).find("span.country_names", "li.ui-sortable-handle").text(name2);
		$(item).find("span.country_names", "li.ui-sortable-handle").text(name1);
		// Balance the commitment
		var newPercentInput = $(clone).find("input." + escapedName + "_percent_input");
		var originalPercentInput = $(item).find("input." + escapedName + "_percent_input");
		var originalPercent = parseFloat($(originalPercentInput).val());
		var newPercent = 1 - originalPercent;
		$(originalPercentInput).val(originalPercent.toFixed(2));
		$(newPercentInput).val(newPercent.toFixed(2));
		balanceCommitment(name, name1, name2, originalPercent, newPercent);
		swapButton(item, name);
		swapButton(clone, name);
		// Rename the ids of the countries
		$(item).attr("id", escapedName + "1_listitem");
		$(item).find("input#" + escapedName + "_percent").attr("id", escapedName + "1_percent");
		$(item).find("input#" + escapedName + "_percent_input").attr("id", escapedName + "1_percent_input");
		$(clone).attr("id", escapedName + "2_listitem");
		$(clone).find("input#" + escapedName + "_percent").attr("id", escapedName + "2_percent");
		$(clone).find("input#" + escapedName + "_percent_input").attr("id", escapedName + "2_percent_input");
		// Limit the max commitment UI elements
		$("#" + escapedName + "2_percent").attr("max", newPercent);
		$("#" + escapedName + "2_percent_input").attr("max", newPercent);
		$("#" + escapedName + "1_percent").attr("max", originalPercent);
		$("#" + escapedName + "1_percent_input").attr("max", originalPercent);
	}

	/**
	 * Deletes the selected partition and merges it back into the full country
	 * by adding both sets of data, maintaining any losses. Basically undos all
	 * that splitCountry() did.
	 * 
	 * @param: original name of country
	 */
	function deletePartition(countryName) {
		// Delete the country partitions, leaving only the original
		var escapedName = countryName.replaceAll(" ", "");
		var clazz = escapedName + "_listitem";
		var partitions = $("li." + clazz);
		var partition1 = $(partitions[0]).find("span." + escapedName).text();
		var partition2 = $(partitions[1]).find("span." + escapedName).text();
		delete countries[partition1];
		delete countries[partition2];
		// Remove the list items and rename the ids
		var item = partitions[0];
		$(partitions[1]).remove();
		$(item).find("span.country_names", "li.ui-sortable-handle").text(countryName);
		$(item).find("input." + escapedName + "_percent_input").attr("max", 1);
		$(item).find("input." + escapedName + "_percent").attr("max", 1);
		$(item).find("input." + escapedName + "_percent_input").val(1);
		$(item).find("input." + escapedName + "_percent").val(1);
		$(item).attr("id", escapedName + "_listitem");
		$(item).find("input[type=range]").attr("id", escapedName + "_percent");
		$(item).find("input[type=number]").attr("id", escapedName + "_percent_input");
		swapButton(item, countryName);
	}

	function balanceCommitment(name, name1, name2, op, np) {
		var newCountry = $.extend(true, {}, countries[name]);
		var oldCountry = $.extend(true, {}, countries[name]);
		$.each(oldCountry, function(turn, turns) {
			$.each(turns, function(type, types) {
				$.each(types, function(name, attribute) {
					if (!isNaN(attribute)) {
						newCountry[turn][type][name] *= np;
						oldCountry[turn][type][name] *= op;
					}
				});
			})
		});
		countries[name1] = oldCountry;
		countries[name2] = newCountry;
	}

	/* Sums an array of country objects */
	function sumCoalition(coalition) {
		var x = 0;
		var sum;
		do {
			sum = $.extend(true, {}, coalition[x]);
		} while (isEmpty(coalition[x++]) && x < coalition.length);
		// Iterate countries
		for (var i = x; i < coalition.length; i++) {
			if (!isEmpty(coalition[i])) {
				// Iterate each type
				$.each(coalition[i], function(type, types) {
					// Iterate each attribute
					// sum[type] = {};
					$.each(types, function(attribute, value) {
						sum[type][attribute] += value;
					});
				});
			}
		}
		return sum;
	}

	/**
	 * Sums all the points of a coalition, before rolling the dice.
	 * 
	 * @param: a coalition object to sum its points
	 * @returns: the total sum of points
	 */
	function sumTotalPoints(coalition) {
		var sum = 0.0;
		if (!isEmpty(coalition)) {
			// Iterate each type
			$.each(coalition, function(type, types) {
				// Iterate each attribute
				$.each(types, function(attribute, value) {
					sum += value;
				});
			});
		}
		return sum;
	}

	/**
	 * Returns a country object with all its attributes multiplied by its
	 * commitment value. Also checks if the coalition is being blockaded and
	 * applies penalties
	 * 
	 * @param country:
	 *            the country in question
	 * @param c:
	 *            its resource commitment value
	 * @return: the intervention value of said country
	 */
	function calculateCommitment(country, c, blockaded) {
		var res = $.extend(true, {}, country);
		$.each(res, function(type, types) {
			$.each(types, function(name, value) {
				res[type][name] *= c;
				// Penalize for blockade
				if (blockaded && type === rules[ECONOMY]) {
					res[type][name] *= rules[BLOCKADE_PENALTY];
				}
			});
		});
		// Disable reserves for 1st roll
		var rollNumber = getRollNumber();
		if (rollNumber == 1) {
			res[rules[MILITARY]][rules[RESERVES]] = 0.0;
		}
		// Penalize reserves for underdeveloped countries
		if (Math.round(res[rules[MILITARY]][rules[DEVELOPED_INFRAESTRUCTURE]]) === 0) {
			if (rollNumber < rules[DEVELOPED_INFRAESTRUCTURE_ROLL]) {
				res[rules[MILITARY]][rules[RESERVES]] = 0.0;
			}
		}
		return res;
	}

	/**
	 * Returns whether a country or its coalition is being blockaded
	 * 
	 * @param: boolean, whether the country or coalition is blockaded
	 */
	function isBlockaded(country, coalition) {
		var res = false;
		var countryCheckboxes = $("[name=" + country.replaceAll(" ", "") + "]");
		var coalitionCheckboxes = $("[name=" + coalition + "]");
		for (var i = 0; i < countryCheckboxes.length; i++) {
			res = res || $(countryCheckboxes[i]).prop("checked");
		}
		for (var i = 0; i < coalitionCheckboxes.length; i++) {
			res = res || $(coalitionCheckboxes[i]).prop("checked");
		}
		return res;
	}

	/* Gets the turn selected from the radio buttons via iteration */
	function getSelectedTurn() {
		var radioList = $("#subscenario_list").find("input:checked");
		var selectedTurn = $(radioList).val();
		return selectedTurn;
	}

	/* Updates the table with the new info */
	function drawCoalitionNavies(turn, attackerNavy, defenderNavy) {
		$("#coalition_navies").find("tr:gt(0)").remove();
		for ( var key in countries) {
			var row = $("<tr>")
			if (Math.round(countries[key][turn][rules[NAVAL]][rules[NAVAL_POWER]]) === 1.0) {
				var intervention = countries[key][turn][rules[NAVAL]];
				var navalPowerNavy = 0;
				for ( var navy in intervention) {
					// Check that avoids the naval power true/false
					if (navy != rules[NAVAL_POWER]) {
						navalPowerNavy += intervention[navy];
					}
				}
				var c1percent = 0.0
				c1percent += attackerNavy / navalPowerNavy;
				var c2percent = 0.0
				c2percent += defenderNavy / navalPowerNavy;
				var npcell = $("<td>");
				$(npcell).append(key);
				var blockadeAttackerCheckbox = $("<input>");
				$(blockadeAttackerCheckbox).attr({
					type : "checkbox",
					// form : "war_form",
					name : "block_attacker",
					value : key.replaceAll(" ", "") + "_blocks_" + "attacker",
					onchange : "updateCountryPoints();",
				});
				var c1cell = $("<td>");
				$(c1cell).append((c1percent * 100).toFixed(2) + ": ");
				$(c1cell).append(blockadeAttackerCheckbox);
				var blockadeDefenderCheckbox = $("<input>");
				$(blockadeDefenderCheckbox).attr({
					type : "checkbox",
					// form : "war_form",
					name : "block_defender",
					value : key.replaceAll(" ", "") + "_blocks_" + "defender",
					onchange : "updateCountryPoints();",
				});
				var c2cell = $("<td>");
				$(c2cell).append((c2percent * 100).toFixed(2) + ": ");
				$(c2cell).append(blockadeDefenderCheckbox);
				$(row).append(npcell);
				$(row).append(c1cell);
				$(row).append(c2cell);
				$("#coalition_navies").append(row);
			}
		}
	}

	function drawCountryNavies(turn, countryNavies) {
		// Set up table and first row
		$("#country_navies").find("tr:gt(0)").remove();
		var firstRow = $("<tr>");
		var tableName = $("<th>");
		tableName.append("Potencias Navales");
		$(firstRow).append(tableName);
		$("#country_navies").append(firstRow);
		// Iterate once per country
		for ( var key in countries) {
			// Add a header per country
			var countryHeader = $("<th>");
			$(countryHeader).append(key);
			$(firstRow).append(countryHeader);
			// If the country is a naval power, add a row for it
			if (Math.round(countries[key][turn][rules[NAVAL]][rules[NAVAL_POWER]]) === 1.0) {
				var intervention = countries[key][turn][rules[NAVAL]];
				var navalPowerNavy = 0;
				for ( var navy in intervention) {
					// Check that avoids the naval power true/false
					if (navy != rules[NAVAL_POWER]) {
						navalPowerNavy += intervention[navy];
					}
				}
				var row = $("<tr>");
				var npcell = $("<td>");
				$(npcell).append(key);
				$(row).append(npcell);
				for ( var c in countryNavies) {
					var cpercent = 0.0;
					cpercent += countryNavies[c] / navalPowerNavy;
					var blockadeCheckbox = $("<input>");
					$(blockadeCheckbox).attr({
						type : "checkbox",
						// form : "war_form",
						name : "block_" + c.replaceAll(" ", ""),
						value : key.replaceAll(" ", "") + "_blocks_" + c.replaceAll(" ", ""),
						onchange : "updateCountryPoints();",
					});
					var ccell = $("<td>");
					$(ccell).append((cpercent * 100).toFixed(2) + ": ");
					$(ccell).append(blockadeCheckbox);
					$(row).append(ccell);
				}
				$("#country_navies").append(row);
			}
		}
	}

	function drawCountryPoints(attackerPoints, defenderPoints) {
		var table = $("#stat_table");
		var turn = getSelectedTurn();
		$(table).find("tr").remove();
		// Iterate the types of attributes
		$.each(attributeValuesTemplate[turn], function(type, attributes) {
			var header = $("<tr>");
			$(header).append($("<th>").append(type));
			$(header).append($("<th>").append("Atacante"));
			$(header).append($("<th>").append("Defensor"));
			$(table).append(header);
			// Iterate the attributes
			$.each(attributes, function(name, value) {
				var row = $("<tr>");
				$(row).append(
						$("<td>").append(name + " &#10005; " + attributeValuesTemplate[turn][type][name] + " pts."));
				var at = (attackerPoints[type] == null) || isEmpty(attackerPoints[type]);
				$(row).append(
						$("<td>").append(
								(attackerPoints[type] == null) || isEmpty(attackerPoints[type]) ? 0
										: attackerPoints[type][name].toFixed(2)));
				$(row).append(
						$("<td>").append(
								(defenderPoints[type] == null) || isEmpty(defenderPoints[type]) ? 0
										: defenderPoints[type][name].toFixed(2)));
				$(table).append(row);
			});
		});
		// Add the sum row:
		var sumrow = $("<tr>");
		$(sumrow).append($("<th>").append("Puntos totales"));
		$(sumrow).append($("<th>").append($("<span>", {
			id : "total_attack_score"
		}).append(sumTotalPoints(attackerPoints).toFixed(2))));
		$(sumrow).append($("<th>").append($("<span>", {
			id : "total_defender_score"
		}).append(sumTotalPoints(defenderPoints).toFixed(2))));
		$(table).append(sumrow);
	}

	/* Calculates the power of navies between coalitions and naval powers */
	function updateCoalitionNavies() {
		var attackerNavy = 0.0;
		var defenderNavy = 0.0;
		var attackerCountries = $("#coal1_box").find("span.country_names", "li.ui-sortable-handle");
		var defenderCountries = $("#coal2_box").find("span.country_names", "li.ui-sortable-handle");
		var turn = getSelectedTurn();
		for (var key = 0; key < attackerCountries.length; key++) {
			var longname = $(attackerCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for ( var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy != rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $("#" + longname.replaceAll(" ", "") + "_percent_input").val();
			attackerNavy += navies * commitment;
		}
		for (var key = 0; key < defenderCountries.length; key++) {
			var longname = $(defenderCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for ( var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy != rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $("#" + longname.replaceAll(" ", "") + "_percent_input").val();
			defenderNavy += navies * commitment;
		}
		drawCoalitionNavies(turn, attackerNavy, defenderNavy);
	}

	/* Calculates the power of navies between naval powers and countries */
	function updateCountryNavies() {
		var turn = getSelectedTurn();
		var countryNavies = {};
		// Grab the names of all the countries from the table
		for ( var key in countries) {
			var longname = key;
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var intervention = countries[name][turn][rules[NAVAL]];
			var navies = 0;
			for ( var navy in intervention) {
				// Check that avoids the naval power true/false
				if (navy != rules[NAVAL_POWER]) {
					navies += intervention[navy];
				}
			}
			var commitment = $("#" + longname.replaceAll(" ", "") + "_percent_input").val();
			// This is so the "parent" country appears in full force when it's
			// partitioned
			if (commitment == null) {
				commitment = 1;
			}
			var finalNavy = navies * commitment;
			countryNavies[longname] = finalNavy;
		}
		drawCountryNavies(turn, countryNavies);
	}

	function updateCountryPoints() {
		var attackerCountries = $("#coal1_box").find("span.country_names", "li.ui-sortable-handle");
		var defenderCountries = $("#coal2_box").find("span.country_names", "li.ui-sortable-handle");
		var turn = getSelectedTurn();
		// Add up the power of coalitions
		var defenders = [];
		var attackers = [];
		/*
		 * To build the coalition, iterate all its countries, and for each: 1.
		 * Get its name 2. Get the commitment 3. Get whether the coalition, or
		 * the country, is being blockaded (blockades don't stack) 4. Build an
		 * "intervention", ie a temporary version of the country, and and that
		 * to the coalition
		 */
		for (var key = 0; key < defenderCountries.length; key++) {
			// TODO: Refactor name.replaceAll() to name
			var longname = $(defenderCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var commitment = $("#" + longname.replaceAll(" ", "") + "_percent_input").val();
			var blockaded = isBlockaded("block_" + longname.replaceAll(" ", ""), "block_defender");
			var intervention = calculateCommitment(countries[name][turn], commitment, blockaded, "defense");
			defenders.push(intervention);
		}
		for (var key = 0; key < attackerCountries.length; key++) {
			var longname = $(attackerCountries[key]).text();
			var name = longname;
			// Remove the suffix if it exists to use the country full values
			var nameSplit = longname.split(" ");
			if (nameSplit.length > 1 && !isNaN(nameSplit.pop())) {
				name = nameSplit.join(" ");
			}
			var commitment = $("#" + longname.replaceAll(" ", "") + "_percent_input").val();
			var blockaded = isBlockaded("block_" + longname.replaceAll(" ", ""), "block_attacker");
			var intervention = calculateCommitment(countries[name][turn], commitment, blockaded, "attack");
			attackers.push(intervention);
		}
		var attackerStats = sumCoalition(attackers);
		var defenderStats = sumCoalition(defenders);

		// Calculate the points
		var attackerPoints = {};
		var defenderPoints = {};
		// First, calculate the total
		var totalStats = sumCoalition([ attackerStats, defenderStats ]);
		// Iterate the total and create an object with attacker and defender
		// points
		var turn = getSelectedTurn();
		$.each(attributeValuesTemplate[turn], function(type, types) {
			attackerPoints[type] = {};
			defenderPoints[type] = {};
			$.each(types, function(name, attribute) {
				if (!isEmpty(totalStats[type])) {
					var total = totalStats[type][name];
					var points = attributeValuesTemplate[turn][type][name];
					if (!isEmpty(attackerStats)) {
						var at = attackerStats[type][name];
						attackerPoints[type][name] = (total === 0) ? attackerStats[type][name]
								: (attackerStats[type][name] / total);
						attackerPoints[type][name] *= points;
						// Apply modifiers:
						// 1. Penalize infantry
						// for attack
						if (rules[INFANTRY].includes(name)) {
							attackerPoints[type][name] *= rules[INFANTRY_ATTACK_PENALTY];
						}
						// Penalize for inland
						// battles
						if (type === rules[NAVAL] && $("#inland_battle").prop("checked")) {
							attackerPoints[type][name] *= rules[INLAND_BATTLE_PENALTY];
						}
					}
					if (!isEmpty(defenderStats)) {
						defenderPoints[type][name] = (total === 0) ? defenderStats[type][name]
								: (defenderStats[type][name] / total);
						defenderPoints[type][name] *= points;
						var def = defenderStats[type][name];
						// Apply modifiers
						// 1. Bonus to infantry
						// for defense
						if (rules[INFANTRY].includes(name)) {
							defenderPoints[type][name] *= rules[INFANTRY_DEFENSE_BONUS];
						}
						// 2. Penalize navies
						// for inland battles
						if (type === rules[NAVAL] && $("#inland_battle").prop("checked")) {
							defenderPoints[type][name] *= rules[INLAND_BATTLE_PENALTY];
						}
					}
				}
			});
		});
		drawCountryPoints(attackerPoints, defenderPoints);
	}

	/**
	 * Loads the previous coalitions in the coalition boxes, by searching for
	 * names in the last result table
	 */
	function loadPreviousCoalitions() {
		var lastAttackersTDs = $("td.last_attacker_country_name");
		var lastDefendersTDs = $("td.last_defender_country_name");
		var attackersList = $("ul#attacker_list");
		var defenderList = $("ul#defender_list");
		for (var i = 0; i < lastAttackersTDs.length; i++) {
			var countryLi = $("#" + $(lastAttackersTDs[i]).text().replaceAll(" ", "") + "_listitem");
			$(attackersList).append(countryLi);
		}
		for (var i = 0; i < lastDefendersTDs.length; i++) {
			var countryLi = $("#" + $(lastDefendersTDs[i]).text().replaceAll(" ", "") + "_listitem");
			$(defenderList).append(countryLi);
		}
	}

	$(document).ready(function() {
		// Load the previous coalitions if they exist
		loadPreviousCoalitions();
		// Sortable list to drag countries to coalitions
		$("ul#country_list, ul#attacker_list, ul#defender_list").sortable({
			connectWith : ".coalition_lists",
			dropOnEmpty : true,
			placeholder : "ui-state-highlight",
			update : function() {
				updateCoalitionNavies();
				updateCountryNavies();
				updateCountryPoints();
				$(this).clone()
			},
		});

		$("ul.coalition_lists").disableSelection();

		$("#war_form").submit(function() {
			// Submit the scores
			$("#attacker_score").val($("#total_attack_score").text());
			$("#defender_score").val($("#total_defender_score").text());
			// Submit the coalitions as a string list such as
			// country,percent; to be parsed by the server
			var attacker = "";
			$.each($("#coal1_box").find("li"), function(key, val) {
				attacker += $(val).attr("name") + "," + $(val).find("input[type=number]").val() + ";";
			});
			$("#attacker_countries").val(attacker);
			var defender = "";
			$.each($("#coal2_box").find("li"), function(key, val) {
				defender += $(val).attr("name") + "," + $(val).find("input[type=number]").val() + ";";
			});
			$("#defender_countries").val(defender);
			return true;
		});
		// Ajax call to get all rules
		$.ajax({
			type : "POST",
			url : "/mapRules",
			success : function(response) {
				rules = response;
				// Ajax call to get the points template
				$.ajax({
					type : "POST",
					url : "/mapAttributes",
					success : function(response) {
						attributeValuesTemplate = response;
						// Ajax call to get all country data to display
						// in tables dynamically
						$.ajax({
							type : "POST",
							url : "/mapCountries",
							success : function(response) {
								countries = response;
								updateCoalitionNavies();
								updateCountryNavies();
								updateCountryPoints();
							}
						});
					}
				});
			}
		});
		$("#error_section").hide();
		$("#war_form").validate({
			focusCleanup : true,
			rules : {
				name : {
					required : true,
					minlength : 2,
					maxlength : 256
				},
				attacker_name : {
					maxlength : 256
				},
				defender_name : {
					maxlength : 256
				}
			},
			messages : {
				name : {
					required : "Especifica un nombre para el enfrentamiento",
					minlength : "El nombre debe tener 2 caracteres como mínimo",
					maxlength : "Máximo 256 caracteres",
				},
				attacker_name : {
					maxlength : "Máximo 256 caracteres",
				},
				defender_name : {
					maxlength : "Máximo 256 caracteres",
				}
			},
			errorPlacement : function(error, element) {
				error.insertAfter(element);
				error.addClass("help is-danger");
				element.addClass("is-danger")
			},
			highlight : function(element) {
				$(element).removeClass("is-danger");
			},
			unhighlight : function(element) {
				$(element).removeClass("is-danger");
			},
		});
	});
</script>
</head>
<body class="content">
	<header th:replace="fragments/session_header :: header"></header>
	<th:block th:if="${rolls!=null and !rolls.empty}">
		<section
			class="section"
			th:each="roll, rollStats : ${rolls}"
			th:if="${rollStats.index == rollStats.size-1}"
			id="last_roll_result">
			<div class="container">
				<h3>Resultado de la &uacute;ltima tirada</h3>
				<table
					id="last_result"
					class="table is-narrow is-bordered is-striped"
					style="display: table; width: 100%; table-layout: fixed;">
					<tr>
						<th colspan="4">Puntuaci&oacute;n</th>
					</tr>
					<tr>
						<th
						style="display: table-cell"
							colspan="2"
							th:text="${roll.attacker.name}"></th>
						<th
						style="display: table-cell"
							colspan="2"
							th:text="${roll.defender.name}"></th>
					</tr>
					<tr>
						<td colspan="2">
							<table
								id="last_attacker_result_table"
								class="table is-narrow is-bordered is-striped"
								style="display: table; width: 100%; table-layout: fixed;width: 100%;">
								<tr th:each="inv, invStats : ${roll.attacker.involvements}">
									<td
										class="last_attacker_country_name"
										th:text="${inv.country.name}"></td>
									<td
										class="last_attacker_country_percent"
										th:text="${inv.involvementPercent}"></td>
								</tr>
							</table>
						</td>
						<td colspan="2">
							<table
								id="last_defender_result_table"
								class="table is-narrow is-bordered is-striped"
								style="display: table; width: 100%; table-layout: fixed;width: 100%;">
								<tr th:each="inv, invStats : ${roll.defender.involvements}">
									<td
										class="last_defender_country_name"
										th:text="${inv.country.name}"></td>
									<td
										class="last_defender_country_percent"
										th:text="${inv.involvementPercent}"></td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<th
							colspan="2"
							th:text="${#numbers.formatDecimal(roll.attackerScore, 0, 2)}"></th>
						<th
							colspan="2"
							th:text="${#numbers.formatDecimal(roll.defenderScore, 0, 2)}"></th>
					</tr>
				</table>
			</div>
		</section>
	</th:block>

	<section
		class="section"
		th:if="${session.fail != null}"
		id="server_error_section">
		<div class="container">
			<h3 class="subtitle is-4 notification is-danger">Se han
				detectado los siguientes errores:</h3>
			<ul id="server_error_list">
				<li
					th:if="${session.fail.warNameError != null}"
					th:text="${session.fail.warNameError}"></li>
				<li
					th:if="${session.fail.attackerNameError != null}"
					th:text="${session.fail.attackerNameError}"></li>
				<li
					th:if="${session.fail.defenderNameError != null}"
					th:text="${session.fail.defenderNameError}"></li>
				<li
					th:if="${session.fail.attackerZeroCountError != null}"
					th:text="${session.fail.attackerZeroCountError}"></li>
				<li
					th:if="${session.fail.defenderZeroCountError != null}"
					th:text="${session.fail.defenderZeroCountError}"></li>
				<li
					th:if="${session.fail.countryInv != null}"
					th:text="${session.fail.countryInv}"></li>
				<li
					th:if="${session.fail.countryNotRecognized != null}"
					th:text="${session.fail.countryNotRecognized}"></li>
									<li
					th:if="${session.fail.turnError != null}"
					th:text="${session.fail.turnError}"></li>
				<li
					th:if="${session.fail.genericRollError != null}"
					th:text="${session.fail.genericRollError}"></li>
			</ul>
		</div>
	</section>
	<section class="section">
		<div class="container">
			<h2 class="subtitle is-3">Comenzar una tirada</h2>
			<h3 class="subtitle is-4">Nombre</h3>
			<form
				id="war_form"
				name="war_form"
				action="#"
				th:action="@{/createRoll}"
				method="post">
				<div class="field">
					<label
						class="label"
						for="name">Nombre del enfrentamiento:</label>
					<div class="control">
						<div th:switch="${session.war.id==null}">
							<input
								th:case="${true}"
								type="text"
								name="name"
								class="input"
								th:value="${name}">
							<input
								th:case="${false}"
								type="text"
								name="name"
								class="input"
								th:value="${session.war.name}"
								readonly="readonly">
						</div>
					</div>
				</div>
				<input
					type="hidden"
					name="attacker_score"
					id="attacker_score"
					value="0">
				<input
					type="hidden"
					name="defender_score"
					id="defender_score"
					value="0">
				<input
					type="hidden"
					name="attacker_countries"
					id="attacker_countries"
					value="">
				<input
					type="hidden"
					name="defender_countries"
					id="defender_countries"
					value="">
			</form>
		</div>
		<div class="container">
			<h3 class="subtitle is-4">
				Subescenario: <a
					class="is-info"
					onclick="toggleTurns();"><span
					th:text="${session.game.activeTurn.subscenario}"></span></a>
			</h3>
			<ul id="subscenario_list">
				<li th:each="turn, turnStat : ${turns}">
					<label th:text="${turn.subscenario}"></label>
					<input
						type="radio"
						th:name="subscenario"
						th:class="subscenario_radio + ' radio'"
						th:id="${turn.subscenario}"
						th:value="${turn.subscenario}"
						th:checked="${session.game.activeTurn==turn}"
						form="war_form"
						th:disabled="${session.game.activeTurn!=turn}">
				</li>
			</ul>
		</div>
	</section>
	<section
		class="section"
		id="coalition_section">
		<div class="container">
			<h3 class="subtitle is-4">Coaliciones</h3>
			<div class="columns is-centered">
				<div class="column">
					<h4 class="subtitle is-5">Coalici&oacute;n Atacante</h4>
					<div class="field">
						<label
							class="label"
							for="attacker_name">Nombre coalici&oacute;n atacante</label>
						<div class="control">
							<input
								type="text"
								name="attacker_name"
								class="input"
								th:value="${lastRoll?.attacker?.name} != null ? ${lastRoll?.attacker?.name} : ${attackerString}"
								th:readonly="${lastRoll!=null}"
								form="war_form">
						</div>
					</div>
					<div
						id="coal1_box"
						style="border: solid 2px;">
						<ul
							id="attacker_list"
							class="coalition_lists"></ul>
					</div>
				</div>
				<div class="column">
					<h4 class="subtitle is-5">Coalici&oacute;n Defensora</h4>
					<div class="field">
						<label
							class="label"
							for="defender_name">Nombre coalici&oacute;n defensora</label>
						<input
							type="text"
							name="defender_name"
							class="input"
							th:value="${lastRoll?.defender?.name} != null ? ${lastRoll?.defender?.name} : ${defenderString}"
							th:readonly="${lastRoll!=null}"
							form="war_form">
					</div>
					<div
						id="coal2_box"
						style="border: solid 2px;">
						<ul
							id="defender_list"
							class="coalition_lists"></ul>
					</div>
				</div>
			</div>
			<h4 class="subtitle is-5">Pa&iacute;ses</h4>
			<div style="border: solid 2px;">
				<ul
					id="country_list"
					class="coalition_lists">
					<li
						th:each="country : ${countries}"
						th:class="${#strings.replace(country.name, ' ', '') + '_listitem'}"
						th:id="${#strings.replace(country.name, ' ', '') + '_listitem'}"
						th:name="${country.name}">
						<span
							th:class="'country_names ' + ${#strings.replace(country.name, ' ', '')}"
							th:text="${country.name}"></span>
						<input
							type="range"
							min=0
							max=1
							step=0.01
							value=1
							th:name="${#strings.replace(country.name, ' ', '') + '_percent'}"
							th:id="${#strings.replace(country.name, ' ', '') + '_percent'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_percent'}"
							oninput="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateTextInput(this, this.value, this.id);"
							onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateTextInput(this, this.value, this.id);">
						<input
							type="number"
							th:name="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							th:id="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_percent_input'}"
							min=0
							max=1
							step=0.01
							value=1
							oninput="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateSliderInput(this, this.value, this.id);"
							onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints();return updateSliderInput(this, this.value, this.id);">
						<button
							type="button"
							th:name="${country.name + '_split'}"
							th:class="${#strings.replace(country.name, ' ', '') + '_split'} + ' button is-small is-outlined is-info'"
							th:id="${country.name + '_split'}"
							th:value="${country.name}"
							onclick="splitCountry(this.value);updateCountryNavies();updateCoalitionNavies;updateCountryPoints()">Dividir</button>
					</li>
				</ul>
			</div>
		</div>
		<div class="container">
			<div class="field">
				<div class="control">
					<form
						action="#"
						th:action="@{/endWar}"
						method="get">
						<input
							class="button is-link is-outlined is-fullwidth"
							type="submit"
							value="Terminar Enfrentamiento">
					</form>
				</div>
			</div>
		</div>
	</section>
	<section class="section">
		<div class="container">
			<h3 class="subtitle is-4">Armadas</h3>
			<div class="field has-text-centered">
				<label
					class="label"
					for="inland_battle">Batalla Interior</label>
				<input
					type="checkbox"
					id="inland_battle"
					name="inland_battle"
					value="inland_battle"
					class="checkbox is-large"
					form="war_form"
					onchange="updateCoalitionNavies();updateCountryNavies();updateCountryPoints()">
			</div>
			<div class="is-medium">
				<h4 class="subtitle is-5">Potencias navales vs. Coaliciones</h4>
				<table
					id="coalition_navies"
					class="table is-bordered">
					<tr>
						<th>Potencias navales</th>
						<th>Porcentaje coalici&oacute;n atacante</th>
						<th>Porcentaje coalici&oacute;n defensora</th>
					</tr>
				</table>
			</div>
			<hr />
			<div class="is-medium">
				<h4 class="subtitle is-5">Potencias navales vs. Pa&iacute;ses</h4>
				<table
					id="country_navies"
					class="table is-bordered">
					<tr>
					</tr>
				</table>
			</div>
		</div>
	</section>
	<section class="section">
		<div class="container">
			<h3 class="subtitle is-4">Puntos disponibles para la tirada
				actual</h3>
			<table
				id="stat_table"
				class="table is-striped is-bordered is-narrow">
			</table>
			<input
				type="submit"
				value="Tirar dado"
				class="button is-fullwidth is-primary"
				form="war_form">
<!-- 				onclick="return validateDieRoll();"> -->
		</div>
	</section>
	<section
		class="section"
		id="error_section">
		<div class="container">
			<h3 class="subtitle is-4 notification is-danger">Se han
				detectado los siguientes errores:</h3>
			<ul id="error_list">
			</ul>
		</div>
	</section>
	<section
		class="section"
		th:if="${session.war.id != null}">
		<div class="container">
			<h3 class="subtitle is-4">Puntos acumulados</h3>
			<table class="class previous_rolls">
				<tr>
					<th>Puntos por tirada</th>
					<th>Atacante</th>
					<th>Defensor</th>
				</tr>
				<tr
					th:each="roll, rollStats : ${rolls}"
					class="prev_roll_row">
					<td th:switch="${rollStats.index}"><span th:case="0">Primera
							Tirada &#10005; 0.15 puntos</span> <span th:case="1">Segunda
							Tirada &#10005; 0.25 puntos</span></td>
					<td th:text="${roll.attackerScore}"></td>
					<td th:text="${roll.defenderScore}"></td>
				</tr>
				<tr id="total_score">
					<th>Puntuaci&oacute;n total</th>
					<th id="attacker_total_score"></th>
					<th id="defender_total_score"></th>
				</tr>
			</table>
		</div>
	</section>
	<footer th:replace="fragments/footer :: footer"></footer>
</body>
</html>